{"version":3,"file":"dap.umd.js","sources":["../src/proxy/cmsis-dap.ts","../src/processor/enums.ts","../src/daplink/text-decoder.ts","../src/daplink/index.ts","../src/dap/adi.ts","../src/processor/cortex-m.ts","../src/transport/hid.ts","../src/transport/usb.ts","../src/transport/webusb.ts"],"sourcesContent":["/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventEmitter } from 'events';\nimport { Transport } from '../transport';\nimport {\n    DAPPort,\n    DAPTransferMode,\n    DAPProtocol,\n    DAPCommand,\n    DAPConnectResponse,\n    DAPResponse,\n    DAPInfoRequest,\n    DAPResetTargeResponse,\n    DAPTransferResponse\n} from './enums';\nimport { Proxy, DAPOperation } from './';\nimport { AbortMask } from '..';\n\n/**\n * @hidden\n */\nexport const DEFAULT_CLOCK_FREQUENCY = 10000000;\n/**\n * @hidden\n */\nconst SWD_SEQUENCE = 0xE79E;\n/**\n * @hidden\n */\nconst JTAG_SEQUENCE = 0xE73C;\n\n/**\n * @hidden\n */\nconst BLOCK_HEADER_SIZE = 4;\n/**\n * @hidden\n */\nconst TRANSFER_HEADER_SIZE = 2;\n/**\n * @hidden\n */\nconst TRANSFER_OPERATION_SIZE = 5;\n\n/**\n * @hidden\n */\nclass Mutex {\n    private locked = false;\n\n    /**\n     * Wait until the Mutex is available and claim it\n     */\n    public async lock(): Promise<void> {\n        while (this.locked) {\n            // Yield the current execution context, effectively moving it to the back of the promise queue\n            await new Promise(resolve => setTimeout(resolve, 1));\n        }\n        this.locked = true;\n    }\n\n    /**\n     * Unlock the Mutex\n     */\n    public unlock(): void {\n        this.locked = false;\n    }\n}\n\n/**\n * CMSIS-DAP class\n * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__Commands__gr.html\n */\nexport class CmsisDAP extends EventEmitter implements Proxy {\n\n    /**\n     * Whether the device has been opened\n     */\n    public connected = false;\n\n    /**\n     * The maximum DAPOperations which can be transferred\n     */\n    public operationCount: number;\n\n    /**\n     * The maximum block size which can be transferred\n     */\n    public blockSize: number;\n\n    private sendMutex = new Mutex();\n\n    /**\n     * CMSIS-DAP constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(private transport: Transport, private mode: DAPProtocol = DAPProtocol.DEFAULT, private clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super();\n\n        // Determine the block size\n        this.blockSize = this.transport.packetSize - BLOCK_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER_BLOCK command\n\n        // Determine the operation count possible\n        const operationSpace = this.transport.packetSize - TRANSFER_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER command\n        this.operationCount = Math.floor(operationSpace / TRANSFER_OPERATION_SIZE);\n    }\n\n    private bufferSourceToUint8Array(prefix: number, data?: BufferSource): Uint8Array {\n\n        if (!data) {\n            return new Uint8Array([prefix]);\n        }\n\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const result = new Uint8Array(arrayBuffer.byteLength + 1);\n\n        result.set([prefix]);\n        result.set(new Uint8Array(arrayBuffer), 1);\n\n        return result;\n    }\n\n    /**\n     * Switches the CMSIS-DAP unit to use SWD\n     * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0316d/Chdhfbhc.html\n     */\n    protected async selectProtocol(protocol: DAPProtocol): Promise<void> {\n        const sequence = protocol === DAPProtocol.JTAG ? JTAG_SEQUENCE : SWD_SEQUENCE;\n\n        await this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])); // Sequence of 1's\n        await this.swjSequence(new Uint16Array([sequence]));                                // Send protocol sequence\n        await this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])); // Sequence of 1's\n        await this.swjSequence(new Uint8Array([0x00]));\n    }\n\n    /**\n     * Send a command\n     * @param command Command to send\n     * @param data Data to use\n     * @returns Promise of DataView\n     */\n    protected async send(command: number, data?: BufferSource): Promise<DataView> {\n        const array = this.bufferSourceToUint8Array(command, data);\n        await this.sendMutex.lock();\n\n        try {\n            await this.transport.write(array);\n            const response = await this.transport.read();\n\n            if (response.getUint8(0) !== command) {\n                throw new Error(`Bad response for ${command} -> ${response.getUint8(0)}`);\n            }\n\n            switch (command) {\n                case DAPCommand.DAP_DISCONNECT:\n                case DAPCommand.DAP_WRITE_ABORT:\n                case DAPCommand.DAP_DELAY:\n                case DAPCommand.DAP_RESET_TARGET:\n                case DAPCommand.DAP_SWJ_CLOCK:\n                case DAPCommand.DAP_SWJ_SEQUENCE:\n                case DAPCommand.DAP_SWD_CONFIGURE:\n                case DAPCommand.DAP_SWD_SEQUENCE:\n                case DAPCommand.DAP_SWO_TRANSPORT:\n                case DAPCommand.DAP_SWO_MODE:\n                case DAPCommand.DAP_SWO_CONTROL:\n                case DAPCommand.DAP_JTAG_CONFIGURE:\n                case DAPCommand.DAP_JTAG_ID_CODE:\n                case DAPCommand.DAP_TRANSFER_CONFIGURE:\n                    if (response.getUint8(1) !== DAPResponse.DAP_OK) {\n                        throw new Error(`Bad status for ${command} -> ${response.getUint8(1)}`);\n                    }\n            }\n\n            return response;\n        } finally {\n            this.sendMutex.unlock();\n        }\n    }\n\n    /**\n     * Clears the abort register of all error flags\n     * @param abortMask Optional AbortMask to use, otherwise clears all flags\n     */\n    protected async clearAbort(abortMask: number = AbortMask.WDERRCLR | AbortMask.STKERRCLR | AbortMask.STKCMPCLR | AbortMask.ORUNERRCLR): Promise<void> {\n        await this.send(DAPCommand.DAP_WRITE_ABORT, new Uint8Array([0, abortMask]));\n    }\n\n    /**\n     * Get DAP information\n     * @param request Type of information to get\n     * @returns Promise of number or string\n     */\n    public async dapInfo(request: DAPInfoRequest): Promise<number | string> {\n        try {\n            const result = await this.send(DAPCommand.DAP_INFO, new Uint8Array([request]));\n            const length = result.getUint8(1);\n\n            if (length === 0) {\n                // String information is not set\n                return '';\n            }\n\n            switch (request) {\n                case DAPInfoRequest.CAPABILITIES:\n                case DAPInfoRequest.PACKET_COUNT:\n                case DAPInfoRequest.PACKET_SIZE:\n                case DAPInfoRequest.SWO_TRACE_BUFFER_SIZE:\n                    // Byte\n                    if (length === 1) return result.getUint8(2);\n\n                    // Short\n                    if (length === 2) return result.getUint16(2);\n\n                    // Word\n                    if (length === 4) return result.getUint32(2);\n            }\n\n            const ascii = Array.prototype.slice.call(new Uint8Array(result.buffer, 2, length));\n            return String.fromCharCode.apply(null, ascii);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send an SWJ Sequence\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Sequence.html\n     * @param sequence The sequence to send\n     * @returns Promise\n     */\n    public async swjSequence(sequence: BufferSource, bitLength: number = sequence.byteLength * 8): Promise<void> {\n        const data = this.bufferSourceToUint8Array(bitLength, sequence);\n\n        try {\n            await this.send(DAPCommand.DAP_SWJ_SEQUENCE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send an SWJ Clock value\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Clock.html\n     * @param clock The SWJ clock value to send\n     * @returns Promise\n     */\n    public async swjClock(clock: number): Promise<void> {\n        try {\n            await this.send(DAPCommand.DAP_SWJ_CLOCK, new Uint8Array([\n                (clock & 0x000000FF),\n                (clock & 0x0000FF00) >> 8,\n                (clock & 0x00FF0000) >> 16,\n                (clock & 0xFF000000) >> 24\n            ]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read/Write SWJ Pins\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Pins.html\n     * @param pinsOut Pin values to write\n     * @param pinSelect Maske to select output pins to change\n     * @param pinWait Time in microseconds to wait for output pin value to stabilize (0 - no wait, 1..3000000)\n     * @returns Promise\n     */\n    public async swjPins(pinsOut: number, pinSelect: number, pinWait: number): Promise<number> {\n        try {\n            const result = await this.send(DAPCommand.DAP_SWJ_PINS, new Uint8Array([\n                pinsOut,\n                pinSelect,\n                (pinWait & 0x000000FF),\n                (pinWait & 0x0000FF00) >> 8,\n                (pinWait & 0x00FF0000) >> 16,\n                (pinWait & 0xFF000000) >> 24\n            ]));\n            return result.getUint8(1);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send Delay Command\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__Delay.html\n     * @param delay Time to delay in microseconds\n     * @returns Promise\n     */\n    public async dapDelay(delay: number): Promise<void> {\n        try {\n            await this.send(DAPCommand.DAP_DELAY, new Uint8Array([\n                (delay & 0x00FF),\n                (delay & 0xFF00) >> 8\n            ]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Configure Transfer\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__TransferConfigure.html\n     * @param idleCycles Number of extra idle cycles after each transfer\n     * @param waitRetry Number of transfer retries after WAIT response\n     * @param matchRetry Number of retries on reads with Value Match in DAP_Transfer\n     * @returns Promise\n     */\n    public async configureTransfer(idleCycles: number, waitRetry: number, matchRetry: number): Promise<void> {\n        const data = new Uint8Array(5);\n        const view = new DataView(data.buffer);\n\n        view.setUint8(0, idleCycles);\n        view.setUint16(1, waitRetry, true);\n        view.setUint16(3, matchRetry, true);\n\n        try {\n            await this.send(DAPCommand.DAP_TRANSFER_CONFIGURE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public async connect(): Promise<void> {\n        if (this.connected === true) {\n            return;\n        }\n\n        await this.transport.open();\n\n        try {\n            await this.send(DAPCommand.DAP_SWJ_CLOCK, new Uint32Array([this.clockFrequency]));\n            const result = await this.send(DAPCommand.DAP_CONNECT, new Uint8Array([this.mode]));\n\n            if (result.getUint8(1) === DAPConnectResponse.FAILED || this.mode !== DAPProtocol.DEFAULT && result.getUint8(1) !== this.mode) {\n                throw new Error('Mode not enabled.');\n            }\n        } catch (error) {\n            await this.clearAbort();\n            await this.transport.close();\n            throw error;\n        }\n\n        try {\n            await this.configureTransfer(0, 100, 0);\n            await this.selectProtocol(DAPProtocol.SWD);\n        } catch (error) {\n            await this.transport.close();\n            throw error;\n        }\n\n        this.connected = true;\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public async disconnect(): Promise<void> {\n        if (this.connected === false) {\n            return;\n        }\n\n        try {\n            await this.send(DAPCommand.DAP_DISCONNECT);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        await this.transport.close();\n        this.connected = false;\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public async reconnect(): Promise<void> {\n        await this.disconnect();\n        await new Promise(resolve => setTimeout(resolve, 100));\n        await this.connect();\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise of whether a device specific reset sequence is implemented\n     */\n    public async reset(): Promise<boolean> {\n        try {\n            const response = await this.send(DAPCommand.DAP_RESET_TARGET);\n            return response.getUint8(2) === DAPResetTargeResponse.RESET_SEQUENCE;\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Transfer data with a single read or write operation\n     * @param port Port type (debug port or access port)\n     * @param mode Whether to read or write\n     * @param register The register to use\n     * @param value Any value to write\n     * @returns Promise of any value read\n     */\n    public transfer(port: DAPPort, mode: DAPTransferMode, register: number, value?: number): Promise<number>;\n    /**\n     * Transfer data with multiple read or write operations\n     * @param operations The operations to use\n     * @returns Promise of any values read\n     */\n    public transfer(operations: DAPOperation[]): Promise<Uint32Array>;\n    public async transfer(portOrOps: DAPPort | DAPOperation[], mode: DAPTransferMode = DAPTransferMode.READ, register: number = 0, value: number = 0): Promise<number | Uint32Array> {\n\n        let operations: DAPOperation[];\n\n        if (typeof portOrOps === 'number') {\n            operations = [{\n                port: portOrOps,\n                mode,\n                register,\n                value\n            }];\n        } else {\n            operations = portOrOps;\n        }\n\n        const data = new Uint8Array(TRANSFER_HEADER_SIZE + (operations.length * TRANSFER_OPERATION_SIZE));\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint8(1, operations.length);\n\n        operations.forEach((operation, index) => {\n            const offset = TRANSFER_HEADER_SIZE + (index * TRANSFER_OPERATION_SIZE);\n\n            // Transfer request\n            view.setUint8(offset, operation.port | operation.mode | operation.register);\n            // Transfer data\n            view.setUint32(offset + 1, operation.value || 0, true);\n        });\n\n        try {\n            const result = await this.send(DAPCommand.DAP_TRANSFER, data);\n\n            // Transfer count\n            if (result.getUint8(1) !== operations.length) {\n                throw new Error('Transfer count mismatch');\n            }\n\n            // Transfer response\n            const response = result.getUint8(2);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error('Transfer response WAIT');\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error('Transfer response FAULT');\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error('Transfer response PROTOCOL_ERROR');\n            }\n            if (response === DAPTransferResponse.VALUE_MISMATCH) {\n                throw new Error('Transfer response VALUE_MISMATCH');\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error('Transfer response NO_ACK');\n            }\n\n            if (typeof portOrOps === 'number') {\n                return result.getUint32(3, true);\n            }\n\n            const length = operations.length * 4;\n            return new Uint32Array(result.buffer.slice(3, 3 + length));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read a block of data from a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @returns Promise of values read\n     */\n    public transferBlock(port: DAPPort, register: number, count: number): Promise<Uint32Array>;\n    /**\n     * Write a block of data to a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @param values The values to write\n     * @returns Promise\n     */\n    public transferBlock(port: DAPPort, register: number, values: Uint32Array): Promise<undefined>;\n    public async transferBlock(port: DAPPort, register: number, countOrValues: number | Uint32Array): Promise<Uint32Array | undefined> {\n\n        let operationCount: number;\n        let mode: DAPTransferMode;\n        let dataSize = BLOCK_HEADER_SIZE;\n\n        if (typeof countOrValues === 'number') {\n            operationCount = countOrValues;\n            mode = DAPTransferMode.READ;\n        } else {\n            operationCount = countOrValues.length;\n            mode = DAPTransferMode.WRITE;\n            dataSize += countOrValues.byteLength;\n        }\n\n        const data = new Uint8Array(dataSize);\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint16(1, operationCount, true);\n        // Transfer request\n        view.setUint8(3, port | mode | register);\n\n        if (typeof countOrValues !== 'number') {\n            // Transfer data\n            countOrValues.forEach((countOrValue, index) => {\n                const offset = BLOCK_HEADER_SIZE + (index * 4);\n                // Transfer data\n                view.setUint32(offset, countOrValue, true);\n            });\n        }\n\n        try {\n            const result = await this.send(DAPCommand.DAP_TRANSFER_BLOCK, view);\n\n            // Transfer count\n            if (result.getUint16(1, true) !== operationCount) {\n                throw new Error('Transfer count mismatch');\n            }\n\n            // Transfer response\n            const response = result.getUint8(3);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error('Transfer response WAIT');\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error('Transfer response FAULT');\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error('Transfer response PROTOCOL_ERROR');\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error('Transfer response NO_ACK');\n            }\n\n            if (typeof countOrValues === 'number') {\n                return new Uint32Array(result.buffer.slice(4, 4 + operationCount * 4));\n            }\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        return undefined;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n/**\n * Processor Core States\n */\nexport const enum CoreState {\n    /**\n     * The core has been reset\n     */\n    RESET,\n    /**\n     * Core is running with a lockup condition\n     */\n    LOCKUP,\n    /**\n     * The core is sleeping\n     */\n    SLEEPING,\n    /**\n     * The core is in debug state\n     */\n    DEBUG,\n    /**\n     * The core is running\n     */\n    RUNNING\n}\n\n/**\n * Processor Core Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100230_0004_00_en/way1435345987733.html\n */\nexport const enum CoreRegister {\n    /**\n     * General purpose register\n     */\n    R0 = 0,\n    /**\n     * General purpose register\n     */\n    R1 = 1,\n    /**\n     * General purpose register\n     */\n    R2 = 2,\n    /**\n     * General purpose register\n     */\n    R3 = 3,\n    /**\n     * General purpose register\n     */\n    R4 = 4,\n    /**\n     * General purpose register\n     */\n    R5 = 5,\n    /**\n     * General purpose register\n     */\n    R6 = 6,\n    /**\n     * General purpose register\n     */\n    R7 = 7,\n    /**\n     * General purpose register\n     */\n    R8 = 8,\n    /**\n     * General purpose register\n     */\n    R9 = 9,\n    /**\n     * General purpose register\n     */\n    R10 = 10,\n    /**\n     * General purpose register\n     */\n    R11 = 11,\n    /**\n     * General purpose register\n     */\n    R12 = 12,\n    /**\n     * Stack Pointer\n     */\n    SP = 13,\n    /**\n     * The Link Register\n     */\n    LR = 14,\n    /**\n     * The Program Counter\n     */\n    PC = 15,\n    /**\n     * The Program Status Register\n     */\n    PSR = 16,\n    /**\n     * Main Stack Pointer\n     */\n    MSP = 17,\n    /**\n     * Process Stack Pointer\n     */\n    PSP = 18,\n    /**\n     * Prevents activation of exceptions\n     */\n    PRIMASK = 20,\n    /**\n     * Controls the stack used\n     */\n    CONTROL = 20\n}\n\n/**\n * Debug Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100165_0201_00_en/ric1417175947147.html\n */\nexport const enum DebugRegister {\n    /**\n     * Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30,\n    /**\n     * Debug Halting Control and Status Register\n     */\n    DHCSR = 0xE000EDF0,\n    /**\n     * Debug Core Register Selector Register, write only\n     */\n    DCRSR = 0xE000EDF4,\n    /**\n     * Debug Core Register Data Register\n     */\n    DCRDR = 0xE000EDF8,\n    /**\n     * Debug Exception and Monitor Control Register\n     */\n    DEMCR = 0xE000EDFC\n}\n\n/**\n * NVIC Registers\n */\nexport const enum NvicRegister {\n    /**\n     * NVIC: Interrupt Controller Type Register\n     */\n    ICT = 0xE000E004,\n    /**\n     * NVIC: CPUID Base Register\n     */\n    CPUID = 0xE000ED00,\n    /**\n     * NVIC: Application Interrupt/Reset Control Register\n     */\n    AIRCR = 0xE000ED0C,\n    /**\n     * NVIC: Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30\n}\n\n/**\n * NVIC: Application Interrupt/Reset Control Register\n * @hidden\n */\nexport const enum AircrMask {\n    /**\n     * Reset Cortex-M (except Debug)\n     */\n    VECTRESET = (1 << 0),\n    /**\n     * Clear Active Vector Bit\n     */\n    VECTCLRACTIVE = (1 << 1),\n    /**\n     * Reset System (except Debug)\n     */\n    SYSRESETREQ = (1 << 2),\n    /**\n     * Write Key\n     */\n    VECTKEY = 0x05FA0000\n}\n\n/**\n * Debug Halting Control and Status Register\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337e/CEGCJAHJ.html\n * @hidden\n */\nexport const enum DhcsrMask {\n    /**\n     * Enables debug\n     */\n    C_DEBUGEN = (1 << 0),\n    /**\n     * Halts the core\n     */\n    C_HALT = (1 << 1),\n    /**\n     * Steps the core in halted debug\n     */\n    C_STEP = (1 << 2),\n    /**\n     * Mask interrupts when stepping or running in halted debug\n     */\n    C_MASKINTS = (1 << 3),\n    /**\n     * Enables Halting debug to gain control\n     */\n    C_SNAPSTALL = (1 << 5),\n    /**\n     * Register Read/Write on the Debug Core Register Selector register is available\n     */\n    S_REGRDY = (1 << 16),\n    /**\n     * The core is in debug state\n     */\n    S_HALT = (1 << 17),\n    /**\n     * Indicates that the core is sleeping\n     */\n    S_SLEEP = (1 << 18),\n    /**\n     * Core is running (not halted) and a lockup condition is present\n     */\n    S_LOCKUP = (1 << 19),\n    /**\n     * An instruction has completed since last read\n     */\n    S_RETIRE_ST = (1 << 24),\n    /**\n     * The core has been reset\n     */\n    S_RESET_ST = (1 << 25),\n    /**\n     * Debug Key\n     */\n    DBGKEY = (0xA05F << 16)\n}\n\n/**\n * Debug Fault Status Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0413d/Cihdifbf.html\n * @hidden\n */\nexport const enum DfsrMask {\n    /**\n     * Halt request flag\n     */\n    HALTED = (1 << 0),\n    /**\n     * BKPT instruction or hardware breakpoint match\n     */\n    BKPT = (1 << 1),\n    /**\n     * Data Watchpoint (DW) flag\n     */\n    DWTTRAP = (1 << 2),\n    /**\n     * Vector catch occurred\n     */\n    VCATCH = (1 << 3),\n    /**\n     * External debug request (EDBGRQ) has halted the core\n     */\n    EXTERNAL = (1 << 4)\n}\n\n/**\n * Debug Core Register Selector Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGIAJBH.html\n * @hidden\n */\nexport const enum DcrsrMask {\n    /**\n     * Register write or read, write is 1\n     */\n    REGWnR = (1 << 16),\n    /**\n     * Register select - DebugReturnAddress & PSR/Flags, Execution Number, and state information\n     */\n    REGSEL = 0x1F,\n}\n\n/**\n * Debug Exception and Monitor Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGHJDCF.html\n * @hidden\n */\nexport const enum DemcrMask {\n    /**\n     * Reset Vector Catch\n     */\n    CORERESET = (1 << 0),\n    /**\n     * Debug Trap on MMU Fault\n     */\n    MMERR = (1 << 4),\n    /**\n     * Debug Trap on No Coprocessor Fault\n     */\n    NOCPERR = (1 << 5),\n    /**\n     * Debug Trap on Checking Error Fault\n     */\n    CHKERR = (1 << 6),\n    /**\n     * Debug Trap on State Error Fault\n     */\n    STATERR = (1 << 7),\n    /**\n     * Debug Trap on Bus Error Fault\n     */\n    BUSERR = (1 << 8),\n    /**\n     * Debug Trap on Interrupt Error Fault\n     */\n    INTERR = (1 << 9),\n    /**\n     * Debug Trap on Hard Fault\n     */\n    HARDERR = (1 << 10),\n    /**\n     * Monitor Enable\n     */\n    MON_EN = (1 << 16),\n    /**\n     * Monitor Pend\n     */\n    MON_PEND = (1 << 17),\n    /**\n     * Monitor Step\n     */\n    MON_STEP = (1 << 18),\n    /**\n     * Monitor Request\n     */\n    MON_REQ = (1 << 19),\n    /**\n     * Trace Enable\n     */\n    TRCENA = (1 << 24)\n}\n\n/**\n * Flash Patch and Breakpoint Registers\n * http://infocenter.arm.com/help/topic/com.arm.doc.100165_0201_00_en/ric1417175949176.html\n * @hidden\n */\nexport const enum FPBRegister {\n    /**\n     * FlashPatch Control Register\n     */\n    FP_CTRL = 0xE0002000,\n    /**\n     * FlashPatch Remap Register\n     */\n    FP_REMAP = 0xE0002004,\n    /**\n     * FlashPatch Comparator Register0\n     */\n    FP_COMP0 = 0xE0002008,\n    /**\n     * FlashPatch Comparator Register1\n     */\n    FP_COMP1 = 0xE000200C,\n    /**\n     * FlashPatch Comparator Register2\n     */\n    FP_COMP2 = 0xE0002010,\n    /**\n     * FlashPatch Comparator Register3\n     */\n    FP_COMP3 = 0xE0002014,\n    /**\n     * FlashPatch Comparator Register4\n     */\n    FP_COMP4 = 0xE0002018,\n    /**\n     * FlashPatch Comparator Register5\n     */\n    FP_COMP5 = 0xE000201C,\n    /**\n     * FlashPatch Comparator Register6\n     */\n    FP_COMP6 = 0xE0002020,\n    /**\n     * FlashPatch Comparator Register7\n     */\n    FP_COMP7 = 0xE0002024,\n}\n\n/**\n * Flash Patch and Breakpoint Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/ch11s04s01.html#BABCAFAG\n * @hidden\n */\nexport enum FPBCtrlMask {\n    /**\n     * Flash patch unit enable\n     */\n    ENABLE = (1 << 0),\n    /**\n     * Key field which enables writing to the Flash Patch Control Register\n     */\n    KEY = (1 << 1)\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2020\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n// https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n\nconst PARTIAL_CHAR_TEST = /[\\xc0-\\xff][\\x80-\\xbf]*$/g;\nconst DOUBLE_BYTE_REPLACE = /[\\xc0-\\xff][\\x80-\\xbf]*/g;\n\nexport class TextDecoder {\n\n    private partialChar: string | undefined;\n\n    /**\n     * Decode an ArrayBuffer to a string, handling double-byte characters\n     * @param input The ArrayBuffer to decode\n     */\n    public decode(input: ArrayBuffer): string {\n\n        const numberArray = Array.prototype.slice.call(new Uint8Array(input));\n        let data = String.fromCodePoint.apply(undefined, numberArray);\n\n        if (this.partialChar) {\n            // Previous double-byte character was cut off\n            data = `${this.partialChar}${data}`;\n            this.partialChar = undefined;\n        }\n\n        const match = data.match(PARTIAL_CHAR_TEST);\n        if (match) {\n            // Partial double-byte character at end of string, save it and truncate data\n            const length = match[0].length;\n            this.partialChar = data.slice(-length);\n            data = data.slice(0, -length);\n        }\n\n        return data.replace(DOUBLE_BYTE_REPLACE, this.decoderReplacer);\n    }\n\n    private decoderReplacer(encoded: string): string {\n        let codePoint = encoded.codePointAt(0)! << 24;\n        const leadingOnes = Math.clz32(~codePoint);\n        let endPos = 0;\n        const stringLen = encoded.length;\n        let result = '';\n        if (leadingOnes < 5 && stringLen >= leadingOnes) {\n            codePoint = (codePoint << leadingOnes) >>> (24 + leadingOnes);\n            for (endPos = 1; endPos < leadingOnes; endPos = endPos + 1) {\n                codePoint = (codePoint << 6) | (encoded.codePointAt(endPos)! & 0x3f);\n            }\n            if (codePoint <= 0xFFFF) { // BMP code point\n                result += String.fromCodePoint(codePoint);\n            } else if (codePoint <= 0x10FFFF) {\n                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint = codePoint - 0x10000;\n                result += String.fromCodePoint(\n                    (codePoint >> 10) + 0xD800,  // highSurrogate\n                    (codePoint & 0x3ff) + 0xDC00 // lowSurrogate\n                );\n            } else endPos = 0; // to fill it in with INVALIDs\n        }\n        for (; endPos < stringLen; endPos = endPos + 1) {\n            result += '\\ufffd'; // replacement character\n        }\n        return result;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { TextDecoder } from './text-decoder';\nimport { CmsisDAP, DAPProtocol, DEFAULT_CLOCK_FREQUENCY } from '../proxy';\nimport { Transport } from '../transport';\nimport { DAPLinkFlash, DAPLinkSerial } from './enums';\n\n/**\n * @hidden\n */\nconst DEFAULT_BAUDRATE = 9600;\n/**\n * @hidden\n */\nconst DEFAULT_SERIAL_DELAY = 100;\n/**\n * @hidden\n */\nconst DEFAULT_PAGE_SIZE = 62;\n\n/**\n * @hidden\n */\nconst decoder = new TextDecoder();\n\n/**\n * DAPLink Class\n */\nexport class DAPLink extends CmsisDAP {\n\n    /**\n     * Progress event\n     * @event\n     */\n    public static EVENT_PROGRESS: string = 'progress';\n\n    /**\n     * Serial read event\n     * @event\n     */\n    public static EVENT_SERIAL_DATA: string = 'serial';\n\n    /**\n     * @hidden\n     */\n    protected serialPolling = false;\n\n    /**\n     * @hidden\n     */\n    protected serialListeners = false;\n\n    /**\n     * DAPLink constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super(transport, mode, clockFrequency);\n\n        this.on('newListener', event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = true;\n                }\n            }\n        });\n\n        this.on('removeListener', event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = false;\n                }\n            }\n        });\n    }\n\n    /**\n     * Detect if buffer contains text or binary data\n     */\n    private isBufferBinary(buffer: ArrayBuffer): boolean {\n        const numberArray = Array.prototype.slice.call(new Uint16Array(buffer, 0, 50));\n        const bufferString: string = String.fromCharCode.apply(null, numberArray);\n\n        for (let i = 0; i < bufferString.length; i++) {\n            const charCode = bufferString.charCodeAt(i);\n            // 65533 is a code for unknown character\n            // 0-8 are codes for control characters\n            if (charCode === 65533 || charCode <= 8) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private async writeBuffer(buffer: ArrayBuffer, pageSize: number, offset: number = 0): Promise<void> {\n        const end = Math.min(buffer.byteLength, offset + pageSize);\n        const page = buffer.slice(offset, end);\n        const data = new Uint8Array(page.byteLength + 1);\n\n        data.set([page.byteLength]);\n        data.set(new Uint8Array(page), 1);\n\n        try {\n            await this.send(DAPLinkFlash.WRITE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        this.emit(DAPLink.EVENT_PROGRESS, offset / buffer.byteLength);\n        if (end < buffer.byteLength) {\n            return this.writeBuffer(buffer, pageSize, end);\n        }\n    }\n\n    /**\n     * Flash the target\n     * @param buffer The image to flash\n     * @param pageSize The page size to use (defaults to 62)\n     * @returns Promise\n     */\n    public async flash(buffer: BufferSource, pageSize: number = DEFAULT_PAGE_SIZE): Promise<void> {\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(buffer) ? buffer.buffer : buffer;\n        const streamType = this.isBufferBinary(arrayBuffer) ? 0 : 1;\n\n        try {\n            let result = await this.send(DAPLinkFlash.OPEN, new Uint32Array([streamType]));\n\n            // An error occurred\n            if (result.getUint8(1) !== 0) {\n                throw new Error('Flash error');\n            }\n\n            await this.writeBuffer(arrayBuffer, pageSize);\n            this.emit(DAPLink.EVENT_PROGRESS, 1.0);\n            result = await this.send(DAPLinkFlash.CLOSE);\n\n            // An error occurred\n            if (result.getUint8(1) !== 0) {\n                throw new Error('Flash error');\n            }\n\n            await this.send(DAPLinkFlash.RESET);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Get the serial baud rate setting\n     * @returns Promise of baud rate\n     */\n    public async getSerialBaudrate(): Promise<number> {\n        try {\n            const result = await this.send(DAPLinkSerial.READ_SETTINGS);\n            return result.getUint32(1, true);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Set the serial baud rate setting\n     * @param baudrate The baudrate to use (defaults to 9600)\n     * @returns Promise\n     */\n    public async setSerialBaudrate(baudrate: number = DEFAULT_BAUDRATE): Promise<void> {\n        try {\n            await this.send(DAPLinkSerial.WRITE_SETTINGS, new Uint32Array([baudrate]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Write serial data\n     * @param data The data to write\n     * @returns Promise\n     */\n    public async serialWrite(data: string): Promise<void> {\n        const arrayData = data.split('').map((e: string) => e.charCodeAt(0));\n        arrayData.unshift(arrayData.length);\n        try {\n            await this.send(DAPLinkSerial.WRITE, new Uint8Array(arrayData).buffer);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read serial data\n     * @returns Promise of any arrayBuffer read\n     */\n    public async serialRead(): Promise<ArrayBuffer | undefined> {\n        try {\n            const serialData = await this.send(DAPLinkSerial.READ);\n            // Check if there is any data returned from the device\n            if (serialData.byteLength === 0) {\n                return undefined;\n            }\n\n            // First byte contains the vendor code\n            if (serialData.getUint8(0) !== DAPLinkSerial.READ) {\n                return undefined;\n            }\n\n            // Second byte contains the actual length of data read from the device\n            const dataLength = serialData.getUint8(1);\n            if (dataLength === 0) {\n                return undefined;\n            }\n\n            const offset = 2;\n            return serialData.buffer.slice(offset, offset + dataLength);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Start listening for serial data\n     * @param serialDelay The serial delay to use (default 100)\n     * @param autoConnect whether to automatically connect to the target (default true)\n     */\n    public async startSerialRead(serialDelay: number = DEFAULT_SERIAL_DELAY, autoConnect = true) {\n        this.serialPolling = true;\n\n        while (this.serialPolling) {\n\n            // Don't read serial output unless we have event listeners\n            if (this.serialListeners) {\n\n                // Remember connection state\n                const connectedState = this.connected;\n\n                if (this.connected === false && autoConnect === true) {\n                    await this.connect();\n                }\n\n                const serialData = await this.serialRead();\n\n                // Put state back\n                if (connectedState === false && autoConnect === true) {\n                    await this.disconnect();\n                }\n\n                if (serialData !== undefined) {\n                    const data = decoder.decode(serialData);\n                    this.emit(DAPLink.EVENT_SERIAL_DATA, data);\n                }\n            }\n\n            await new Promise(resolve => setTimeout(resolve, serialDelay));\n        }\n    }\n\n    /**\n     * Stop listening for serial data\n     */\n    public stopSerialRead() {\n        this.serialPolling = false;\n    }\n}\n\nexport * from './enums';\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from '../transport';\nimport { Proxy, CmsisDAP, DAPOperation } from '../proxy';\nimport { DPRegister, APRegister, CSWMask, BankSelectMask, AbortMask, CtrlStatMask } from './enums';\nimport { DAP } from './';\nimport { DAPTransferMode, DAPPort, DAPProtocol } from '../proxy/enums';\nimport { DEFAULT_CLOCK_FREQUENCY } from '../proxy/cmsis-dap';\n\n/**\n * @hidden\n */\nconst DEFAULT_WAIT_DELAY = 100;\n\n// auto-increment beyond 1kB (10 bits) is implementation defined, see:\n// https://developer.arm.com/documentation/ihi0031/a/The-Memory-Access-Port--MEM-AP-/MEM-AP-functions/Auto-incrementing-the-Transfer-Address-Register--TAR-\nconst DEFAULT_AUTOINC_PAGESIZE = (1 << 10);\n\n/**\n * Arm Debug Interface class\n */\nexport class ADI implements DAP {\n\n    private selectedAddress?: number;\n    private cswValue?: number;\n    private proxy: Proxy;\n\n    /**\n     * ADI constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use (default 0)\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode?: DAPProtocol, clockFrequency?: number);\n    /**\n     * ADI constructor\n     * @param proxy Proxy to use\n     */\n    constructor(proxy: Proxy);\n    constructor(transportOrDap: Transport | Proxy, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        const isTransport = (test: Transport | Proxy): test is Transport => {\n            return (test as Transport).open !== undefined;\n        };\n\n        this.proxy = isTransport(transportOrDap) ? new CmsisDAP(transportOrDap, mode, clockFrequency) : transportOrDap;\n    }\n\n    /**\n     * Continually run a function until it returns true\n     * @param fn The function to run\n     * @param timeout Optional timeout to wait before giving up and throwing\n     * @param delay The milliseconds to wait between each run\n     * @returns Promise\n     */\n    protected async waitDelay(fn: () => Promise<boolean>, timeout: number = 0, delay: number = DEFAULT_WAIT_DELAY): Promise<void> {\n        let running = true;\n\n        if (timeout > 0) {\n            setTimeout(() => {\n                if (running) {\n                    running = false;\n                    throw new Error('Wait timed out');\n                }\n            }, timeout);\n        }\n\n        while (running) {\n            const result = await fn();\n            if (result === true) {\n                running = false;\n                return;\n            }\n\n            if (delay > 0) {\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n    }\n\n    protected concatTypedArray(arrays: Uint32Array[]): Uint32Array {\n        // Only one array exists\n        if (arrays.length === 1) return arrays[0];\n\n        // Determine array length\n        let length: number = 0;\n        for (const array of arrays) {\n            length += array.length;\n        }\n\n        // Concat the arrays\n        const result = new Uint32Array(length);\n        for (let i = 0, j = 0; i < arrays.length; i++) {\n            result.set(arrays[i], j);\n            j += arrays[i].length;\n        }\n\n        return result;\n    }\n\n    protected readDPCommand(register: number): DAPOperation[] {\n        return [{\n            mode: DAPTransferMode.READ,\n            port: DAPPort.DEBUG,\n            register\n        }];\n    }\n\n    protected writeDPCommand(register: number, value: number): DAPOperation[] {\n        if (register === DPRegister.SELECT) {\n            if (value === this.selectedAddress) {\n                return [];\n            }\n            this.selectedAddress = value;\n        }\n\n        return [{\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.DEBUG,\n            register,\n            value\n        }];\n    }\n\n    protected readAPCommand(register: number): DAPOperation[] {\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.READ,\n            port: DAPPort.ACCESS,\n            register\n        });\n    }\n\n    protected writeAPCommand(register: number, value: number): DAPOperation[] {\n        if (register === APRegister.CSW) {\n            if (value === this.cswValue) {\n                return [];\n            }\n            this.cswValue = value;\n        }\n\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.ACCESS,\n            register,\n            value\n        });\n    }\n\n    protected readMem8Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_8)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem8Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_8)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem16Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem16Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem32Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem32Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.writeAPCommand(APRegister.DRW, value as number));\n    }\n\n    protected async transferSequence(operations: DAPOperation[][]): Promise<Uint32Array> {\n        // Flatten operations into single array\n        let merged: DAPOperation[] = [];\n        merged = merged.concat(...operations);\n\n        const results: Uint32Array[] = [];\n\n        // Split operations into sequences no longer than operation count\n        while (merged.length) {\n            const sequence = merged.splice(0, this.proxy.operationCount);\n            const result = await this.proxy.transfer(sequence);\n            results.push(result);\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public async connect() {\n        const mask = CtrlStatMask.CDBGPWRUPACK | CtrlStatMask.CSYSPWRUPACK;\n\n        await this.proxy.connect();\n        await this.readDP(DPRegister.DPIDR);\n        await this.transferSequence([\n            this.writeDPCommand(DPRegister.ABORT, AbortMask.STKERRCLR), // clear sticky error\n            this.writeDPCommand(DPRegister.SELECT, APRegister.CSW), // select CTRL_STAT\n            this.writeDPCommand(DPRegister.CTRL_STAT, CtrlStatMask.CSYSPWRUPREQ | CtrlStatMask.CDBGPWRUPREQ)\n        ]);\n\n        // Wait until system and debug have powered up\n        await this.waitDelay(async () => {\n            const status = await this.readDP(DPRegister.CTRL_STAT);\n            return (status & mask) === mask;\n        });\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public disconnect(): Promise<void> {\n        return this.proxy.disconnect();\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public async reconnect(): Promise<void> {\n        await this.disconnect();\n        await new Promise(resolve => setTimeout(resolve, DEFAULT_WAIT_DELAY));\n        await this.connect();\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise\n     */\n    public reset(): Promise<boolean> {\n        return this.proxy.reset();\n    }\n\n    /**\n     * Read from a debug port register\n     * @param register DP register to read\n     * @returns Promise of register value\n     */\n    public async readDP(register: DPRegister): Promise<number> {\n        const result = await this.proxy.transfer(this.readDPCommand(register));\n        return result[0];\n    }\n\n    /**\n     * Write to a debug port register\n     * @param register DP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public async writeDP(register: DPRegister, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeDPCommand(register, value));\n    }\n\n    /**\n     * Read from an access port register\n     * @param register AP register to read\n     * @returns Promise of register value\n     */\n    public async readAP(register: APRegister): Promise<number> {\n        const result = await this.proxy.transfer(this.readAPCommand(register));\n        return result[0];\n    }\n\n    /**\n     * Write to an access port register\n     * @param register AP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public async writeAP(register: APRegister, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeAPCommand(register, value));\n    }\n\n    /**\n     * Read an 8-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem8(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem8Command(register));\n        return result[0] as number >> ((register & 0x03) << 3) & 0xFF;\n    }\n\n    /**\n     * Write an 8-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem8(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x03) << 3);\n        await this.proxy.transfer(this.writeMem8Command(register, value));\n    }\n\n    /**\n     * Read a 16-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem16(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem16Command(register));\n        return result[0] as number >> ((register & 0x02) << 3) & 0xFFFF;\n    }\n\n    /**\n     * Write a 16-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem16(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x02) << 3);\n        await this.proxy.transfer(this.writeMem16Command(register, value));\n    }\n\n    /**\n     * Read a 32-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem32(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem32Command(register));\n        return result[0];\n    }\n\n    /**\n     * Write a 32-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem32(register: number, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeMem32Command(register, value));\n    }\n\n    /**\n     * Read a sequence of 32-bit words from a memory access port register, without crossing TAR auto-increment boundaries\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    protected async readMem32Sequence(register: number, count: number): Promise<Uint32Array> {\n        await this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register)\n        ]);\n\n        const results: Uint32Array[] = [];\n\n        // Split into requests no longer than block size\n        let remainder = count;\n        while (remainder > 0) {\n            const chunkSize = Math.min(remainder, Math.floor(this.proxy.blockSize / 4));\n            const result = await this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunkSize);\n            results.push(result);\n            remainder -= chunkSize;\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Write a sequence of 32-bit words to a memory access port register, without crossing TAR auto-increment boundaries\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    protected async writeMem32Sequence(register: number, values: Uint32Array): Promise<void> {\n        await this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register)\n        ]);\n\n        // Split values into chunks no longer than block size\n        let index = 0;\n        while (index < values.length) {\n            const chunk = values.slice(index, index + Math.floor(this.proxy.blockSize / 4));\n            await this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunk);\n            index += Math.floor(this.proxy.blockSize / 4);\n        }\n    }\n\n    /**\n     * Read a block of 32-bit words from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public async readBlock(register: number, count: number): Promise<Uint32Array> {\n        const results: Uint32Array[] = [];\n\n        // Split into reads that do not cross TAR autoincrement boundaries\n        let remainder = count;\n        while (remainder > 0) {\n            const nextPageOffset = DEFAULT_AUTOINC_PAGESIZE - (register % DEFAULT_AUTOINC_PAGESIZE);\n            const chunkSize = Math.min(remainder, nextPageOffset / 4);\n            const result = await this.readMem32Sequence(register, chunkSize);\n            results.push(result);\n            register += chunkSize * 4;\n            remainder -= chunkSize;\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Write a block of 32-bit words to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public async writeBlock(register: number, values: Uint32Array): Promise<void> {\n        // Split into writes that do not cross TAR autoincrement boundaries\n        let index = 0;\n        while (index < values.length) {\n            const nextPageOffset = DEFAULT_AUTOINC_PAGESIZE - (register % DEFAULT_AUTOINC_PAGESIZE);\n            const chunkSize = Math.min(values.length - index, nextPageOffset / 4);\n            const chunk = values.slice(index, index + chunkSize);\n            await this.writeMem32Sequence(register, chunk);\n            register += chunkSize * 4;\n            index += chunkSize;\n        }\n    }\n\n    /**\n     * Read a block of bytes from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public async readBytes(register: number, count: number): Promise<Uint8Array> {\n        // read a word-aligned chunk of 32-bit words containing the requested range, then trim it\n        let bytesToRead = count;\n        const startOffset = register & 0x03;\n        const endOffset = (register + count) & 0x03;\n\n        // include left-most 32-bit word\n        if (startOffset) {\n            register -= startOffset;\n            bytesToRead += startOffset;\n        }\n\n        // include right-most 32-bit word\n        if (endOffset) {\n            bytesToRead += (4 - endOffset);\n        }\n\n        const result = await this.readBlock(register, bytesToRead / 4);\n        return new Uint8Array(result.buffer).slice(startOffset, startOffset + count);\n    }\n\n    /**\n     * Write a block of bytes to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public async writeBytes(register: number, values: Uint8Array): Promise<void> {\n        let bytesToWrite = values.length;\n        let index = 0;\n\n        // initial byte write\n        if ((bytesToWrite > 0) && (register & 0x01)) {\n            await this.writeMem8(register, values[index]);\n            bytesToWrite -= 1;\n            register += 1;\n            index += 1;\n        }\n\n        // initial 16-bit word write\n        if ((bytesToWrite > 1) && (register & 0x02)) {\n            await this.writeMem16(register, values[index] | (values[index + 1] << 8));\n            bytesToWrite -= 2;\n            register += 2;\n            index += 2;\n        }\n\n        // chunk of word-aligned 32-bit words\n        if (bytesToWrite >= 4) {\n            const chunkSize = bytesToWrite - bytesToWrite % 4;\n            const chunk = new Uint32Array(values.slice(index, index + chunkSize).buffer);\n            await this.writeBlock(register, chunk);\n            bytesToWrite -= chunkSize;\n            register += chunkSize;\n            index += chunkSize;\n        }\n\n        // trailing 16-bit word write\n        if (bytesToWrite > 1) {\n            await this.writeMem16(register, values[index] | (values[index + 1] << 8));\n            bytesToWrite -= 2;\n            register += 2;\n            index += 2;\n        }\n\n        // tailing byte write\n        if (bytesToWrite > 0) {\n            await this.writeMem8(register, values[index]);\n        }\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { ADI } from '../dap';\nimport {\n    DebugRegister,\n    CoreRegister,\n    DhcsrMask,\n    DfsrMask,\n    DcrsrMask,\n    CoreState,\n    NvicRegister,\n    AircrMask,\n    DemcrMask\n} from './enums';\nimport { Processor } from './';\nimport { DAPOperation } from '../proxy';\n\n/**\n * @hidden\n */\nconst EXECUTE_TIMEOUT = 10000;\n/**\n * @hidden\n */\nconst BKPT_INSTRUCTION = 0xBE2A;\n/**\n * @hidden\n */\nconst GENERAL_REGISTER_COUNT = 12;\n\n/**\n * Cortex M class\n */\nexport class CortexM extends ADI implements Processor {\n\n    private enableDebug() {\n        return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN);\n    }\n\n    protected readCoreRegisterCommand(register: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRSR, register)\n            .concat(this.readMem32Command(DebugRegister.DHCSR))\n            .concat(this.readMem32Command(DebugRegister.DCRDR));\n    }\n\n    protected writeCoreRegisterCommand(register: number, value: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRDR, value)\n            .concat(this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR));\n    }\n\n    /**\n     * Get the state of the processor core\n     * @returns Promise of CoreState\n     */\n    public async getState(): Promise<CoreState> {\n        const dhcsr = await this.readMem32(DebugRegister.DHCSR);\n        let state: CoreState;\n\n        if (dhcsr & DhcsrMask.S_LOCKUP) state = CoreState.LOCKUP;\n        else if (dhcsr & DhcsrMask.S_SLEEP) state = CoreState.SLEEPING;\n        else if (dhcsr & DhcsrMask.S_HALT) state = CoreState.DEBUG;\n        else state = CoreState.RUNNING;\n\n        if (dhcsr & DhcsrMask.S_RESET_ST) {\n            // The core has been reset, check if an instruction has run\n            const newDhcsr = await this.readMem32(DebugRegister.DHCSR);\n            if (newDhcsr & DhcsrMask.S_RESET_ST && !(newDhcsr & DhcsrMask.S_RETIRE_ST)) {\n                return CoreState.RESET;\n            } else {\n                return state;\n            }\n        } else {\n            return state;\n        }\n    }\n\n    /**\n     * Whether the target is halted\n     * @returns Promise of halted state\n     */\n    public async isHalted(): Promise<boolean> {\n        const dhcsr = await this.readMem32(DebugRegister.DHCSR);\n        return !!(dhcsr & DhcsrMask.S_HALT);\n    }\n\n    /**\n     * Halt the target\n     * @param wait Wait until halted before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public async halt(wait: boolean = true, timeout: number = 0): Promise<void> {\n        const halted = await this.isHalted();\n\n        if (halted) {\n            return;\n        }\n\n        await this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN | DhcsrMask.C_HALT);\n\n        if (!wait) {\n            return;\n        }\n\n        return this.waitDelay(() => this.isHalted(), timeout);\n    }\n\n    /**\n     * Resume a target\n     * @param wait Wait until resumed before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public async resume(wait: boolean = true, timeout: number = 0) {\n        const halted = await this.isHalted();\n\n        if (!halted) {\n            return;\n        }\n\n        await this.writeMem32(DebugRegister.DFSR, DfsrMask.DWTTRAP | DfsrMask.BKPT | DfsrMask.HALTED);\n        await this.enableDebug();\n\n        if (!wait) {\n            return;\n        }\n\n        return this.waitDelay(async () => {\n            const result = await this.isHalted();\n            return !result;\n        }, timeout);\n    }\n\n    /**\n     * Read from a core register\n     * @param register The register to read\n     * @returns Promise of value\n     */\n    public async readCoreRegister(register: CoreRegister): Promise<number> {\n        const results = await this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRSR, register),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ]);\n\n        const dhcsr = results[0];\n        if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n            throw new Error('Register not ready');\n        }\n\n        return this.readMem32(DebugRegister.DCRDR);\n    }\n\n    /**\n     * Read an array of core registers\n     * @param registers The registers to read\n     * @returns Promise of register values in an array\n     */\n    public async readCoreRegisters(registers: CoreRegister[]): Promise<number[]> {\n        const results: number[] = [];\n\n        for (const register of registers) {\n            const result = await this.readCoreRegister(register);\n            results.push(result);\n        }\n\n        return results;\n    }\n\n    /**\n     * Write to a core register\n     * @param register The register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeCoreRegister(register: CoreRegister, value: number): Promise<void> {\n        const results = await this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRDR, value),\n            this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ]);\n\n        const dhcsr = results[0];\n        if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n            throw new Error('Register not ready');\n        }\n    }\n\n    /**\n     * Exucute code at a specified memory address\n     * @param address The address to put the code\n     * @param code The code to use\n     * @param stackPointer The stack pointer to use\n     * @param programCounter The program counter to use\n     * @param linkRegister The link register to use (defaults to address + 1)\n     * @param registers Values to add to the general purpose registers, R0, R1, R2, etc.\n     */\n    public async execute(address: number, code: Uint32Array, stackPointer: number, programCounter: number, linkRegister: number = address + 1, ...registers: number[]): Promise<void> {\n        // Ensure a breakpoint exists at the end of the code\n        if (code[code.length - 1] !== BKPT_INSTRUCTION) {\n            const newCode = new Uint32Array(code.length + 1);\n            newCode.set(code);\n            newCode.set([BKPT_INSTRUCTION], code.length - 1);\n            code = newCode;\n        }\n\n        // Create sequence of core register writes\n        const sequence = [\n            this.writeCoreRegisterCommand(CoreRegister.SP, stackPointer),\n            this.writeCoreRegisterCommand(CoreRegister.PC, programCounter),\n            this.writeCoreRegisterCommand(CoreRegister.LR, linkRegister)\n        ];\n\n        // Add in register values R0, R1, R2, etc.\n        for (let i = 0; i < Math.min(registers.length, GENERAL_REGISTER_COUNT); i++) {\n            sequence.push(this.writeCoreRegisterCommand(i, registers[i]));\n        }\n\n        // Add xPSR.\n        sequence.push(this.writeCoreRegisterCommand(CoreRegister.PSR, 0x01000000));\n\n        await this.halt(); // Halt the target\n        await this.transferSequence(sequence); // Write the registers\n        await this.writeBlock(address, code); // Write the code to the address\n        await this.resume(false); // Resume the target, without waiting\n        await this.waitDelay(() => this.isHalted(), EXECUTE_TIMEOUT); // Wait for the target to halt on the breakpoint\n    }\n\n    /**\n     * soft reset the target\n     * @param None\n     * @returns Promise\n     */\n    public async softReset(): Promise<void> {\n        await this.writeMem32(DebugRegister.DEMCR, 0);\n        return this.writeMem32(NvicRegister.AIRCR, AircrMask.VECTKEY | AircrMask.SYSRESETREQ);\n    }\n\n    /**\n     * set the target to reset state\n     * @param hardwareReset use hardware reset pin or software reset\n     * @returns Promise\n     */\n    public async setTargetResetState(hardwareReset: boolean = true): Promise<void> {\n        await this.writeMem32(DebugRegister.DEMCR, DemcrMask.CORERESET);\n\n        if (hardwareReset === true) {\n            await this.reset();\n        } else {\n            const value = await this.readMem32(NvicRegister.AIRCR);\n            await this.writeMem32(NvicRegister.AIRCR, AircrMask.VECTKEY | value | AircrMask.SYSRESETREQ);\n        }\n\n        await this.writeMem32(DebugRegister.DEMCR, 0);\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { platform } from 'os';\nimport type { HID as nodeHID } from 'node-hid';\nimport { Transport } from './';\n\n/**\n * HID Transport class\n */\nexport class HID implements Transport {\n\n    private os: string = platform();\n    public readonly packetSize = 64;\n\n    /**\n     * HID constructor\n     * @param path Path to HID device to use\n     */\n    constructor(private device: nodeHID) {\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        return;\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        const array = await new Promise<number[]>((resolve, reject) => {\n            this.device!.read((error: string, data: number[]) => {\n                if (error) {\n                    return reject(new Error(error));\n                } else {\n                    resolve(data);\n                }\n            });\n        });\n\n        const buffer = new Uint8Array(array).buffer;\n        return new DataView(buffer);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const array = Array.prototype.slice.call(new Uint8Array(arrayBuffer));\n\n        // Pad to packet size\n        while (array.length < this.packetSize) array.push(0);\n\n        // Windows requires the prepend of an extra byte\n        // https://github.com/node-hid/node-hid/blob/master/README.md#prepend-byte-to-hid_write\n        if (this.os === 'win32') {\n            array.unshift(0);  // prepend throwaway byte\n        }\n\n        const bytesWritten = this.device.write(array);\n        if (bytesWritten !== array.length) {\n            throw new Error('Incorrect bytecount written');\n        }\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport type { Device, InEndpoint, OutEndpoint} from 'usb';\nimport { Transport } from './';\n\n/**\n * @hidden\n */\nconst LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5);\n/**\n * @hidden\n */\nconst LIBUSB_RECIPIENT_INTERFACE = 0x01;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_OUT = 0x00;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_IN = 0x80;\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * USB Transport class\n */\nexport class USB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: InEndpoint;\n    private endpointOut?: OutEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * USB constructor\n     * @param device USB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: Device, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private bufferToDataView(buffer: Buffer): DataView {\n        const arrayBuffer = new Uint8Array(buffer).buffer;\n        return new DataView(arrayBuffer);\n    }\n\n    private isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n        return (source as ArrayBufferView).buffer !== undefined;\n    }\n\n    private bufferSourceToBuffer(bufferSource: ArrayBuffer | ArrayBufferView): Buffer {\n        const arrayBuffer = this.isView(bufferSource) ? bufferSource.buffer : bufferSource;\n        return Buffer.from(arrayBuffer);\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        const arrayBuffer = this.isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        this.device.open();\n\n        await new Promise<void>((resolve, reject) => {\n            this.device.setConfiguration(this.configuration, error => {\n                if (error) {\n                    reject(new Error(error.message));\n                } else {\n                    resolve();\n                }\n            });\n        });\n\n        const interfaces = this.device.interfaces?.filter(iface => {\n            return iface.descriptor.bInterfaceClass === this.interfaceClass;\n        });\n\n        if (!interfaces?.length) {\n            throw new Error('No valid interfaces found.');\n        }\n\n        // Prefer interface with endpoints\n        let selectedInterface = interfaces.find(iface => iface.endpoints.length > 0);\n\n        // Otherwise use the first\n        if (!selectedInterface) {\n            selectedInterface = interfaces[0];\n        }\n\n        this.interfaceNumber = selectedInterface.interfaceNumber;\n\n        // If we always want to use control transfer, don't find/set endpoints and claim interface\n        if (!this.alwaysControlTransfer) {\n            const endpoints = selectedInterface.endpoints;\n\n            this.endpointIn = undefined;\n            this.endpointOut = undefined;\n\n            for (const endpoint of endpoints) {\n                if (endpoint.direction === 'in' && !this.endpointIn) this.endpointIn = (endpoint as InEndpoint);\n                else if (endpoint.direction === 'out' && !this.endpointOut) this.endpointOut = (endpoint as OutEndpoint);\n            }\n\n            // If endpoints are found, claim the interface\n            if (this.endpointIn || this.endpointOut) {\n\n                // If the interface can't be claimed, use control transfer\n                try {\n                    selectedInterface.claim();\n                } catch (_e) {\n                    this.endpointIn = undefined;\n                    this.endpointOut = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const result = await new Promise<Buffer>((resolve, reject) => {\n            // Use endpoint if it exists\n            if (this.endpointIn) {\n                this.endpointIn.transfer(this.packetSize, (exception, buffer) => {\n                    if (exception) {\n                        reject(exception);\n                    } else {\n                        if (buffer !== undefined) {\n                            resolve(buffer);\n                        } else {\n                            resolve(new Buffer(0));\n                        }\n                    }\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                GET_REPORT,\n                IN_REPORT,\n                this.interfaceNumber!,\n                this.packetSize,\n                (exception, buffer) => {\n                    if (exception) {\n                        reject(exception);\n                    } else if (!buffer) {\n                        reject(new Error('No buffer read'));\n                    } else {\n                        // Buffer type for IN transfer\n                        resolve(buffer as Buffer);\n                    }\n                }\n            );\n        });\n\n        return this.bufferToDataView(result);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const extended = this.extendBuffer(data, this.packetSize);\n        const buffer = this.bufferSourceToBuffer(extended);\n\n        await new Promise<void>((resolve, reject) => {\n            // Use endpoint if it exists\n            if (this.endpointOut) {\n                this.endpointOut.transfer(buffer, exception => {\n                    if (exception) {\n                        return reject(exception);\n                    } else {\n                        resolve();\n                    }\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                SET_REPORT,\n                OUT_REPORT,\n                this.interfaceNumber!,\n                buffer,\n                exception => {\n                    if (exception) {\n                        return reject(exception);\n                    } else {\n                        resolve();\n                    }\n                }\n            );\n        });\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from './';\n\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * WebUSB Transport class\n * https://wicg.github.io/webusb/\n */\nexport class WebUSB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: USBEndpoint;\n    private endpointOut?: USBEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * WebUSB constructor\n     * @param device WebUSB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: USBDevice, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        await this.device.open();\n        await this.device.selectConfiguration(this.configuration);\n\n        const interfaces = this.device.configuration!.interfaces.filter(iface => {\n            return iface.alternates[0].interfaceClass === this.interfaceClass;\n        });\n\n        if (!interfaces.length) {\n            throw new Error('No valid interfaces found.');\n        }\n\n        // Prefer interface with endpoints\n        let selectedInterface = interfaces.find(iface => iface.alternates[0].endpoints.length > 0);\n\n        // Otherwise use the first\n        if (!selectedInterface) {\n            selectedInterface = interfaces[0];\n        }\n\n        this.interfaceNumber = selectedInterface.interfaceNumber;\n\n        // If we always want to use control transfer, don't find/set endpoints and claim interface\n        if (!this.alwaysControlTransfer) {\n            const endpoints = selectedInterface.alternates[0].endpoints;\n\n            this.endpointIn = undefined;\n            this.endpointOut = undefined;\n\n            for (const endpoint of endpoints) {\n                if (endpoint.direction === 'in' && !this.endpointIn) this.endpointIn = endpoint;\n                else if (endpoint.direction === 'out' && !this.endpointOut) this.endpointOut = endpoint;\n            }\n        }\n\n        return this.device.claimInterface(this.interfaceNumber);\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        let result: USBInTransferResult;\n\n        if (this.endpointIn) {\n            // Use endpoint if it exists\n            result = await this.device.transferIn(\n                this.endpointIn.endpointNumber,\n                this.packetSize\n            );\n        } else {\n            // Fallback to using control transfer\n            result = await this.device.controlTransferIn(\n                {\n                    requestType: 'class',\n                    recipient: 'interface',\n                    request: GET_REPORT,\n                    value: IN_REPORT,\n                    index: this.interfaceNumber\n                },\n                this.packetSize\n            );\n        }\n\n        return result.data!;\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const buffer = this.extendBuffer(data, this.packetSize);\n\n        if (this.endpointOut) {\n            // Use endpoint if it exists\n            await this.device.transferOut(\n                this.endpointOut.endpointNumber,\n                buffer\n            );\n        } else {\n            // Fallback to using control transfer\n            await this.device.controlTransferOut(\n                {\n                    requestType: 'class',\n                    recipient: 'interface',\n                    request: SET_REPORT,\n                    value: OUT_REPORT,\n                    index: this.interfaceNumber\n                },\n                buffer\n            );\n        }\n    }\n}\n"],"names":["FPBCtrlMask","DEFAULT_CLOCK_FREQUENCY","Mutex","this","locked","prototype","lock","Promise","resolve","setTimeout","_a","sent","unlock","CmsisDAP","_super","transport","mode","clockFrequency","_this","connected","sendMutex","blockSize","packetSize","operationSpace","operationCount","Math","floor","__extends","bufferSourceToUint8Array","prefix","data","Uint8Array","arrayBuffer","undefined","buffer","result","byteLength","set","selectProtocol","protocol","sequence","swjSequence","Uint16Array","send","command","array","write","read","response","getUint8","Error","concat","clearAbort","abortMask","dapInfo","request","length_1","getUint16","getUint32","ascii","Array","slice","call","String","fromCharCode","apply","error_1","sequence_1","__awaiter","arguments","bitLength","error_2","swjClock","clock","error_3","swjPins","pinsOut","pinSelect","pinWait","error_4","dapDelay","delay","error_5","configureTransfer","idleCycles","waitRetry","matchRetry","view","DataView","setUint8","setUint16","error_6","connect","open","Uint32Array","close","error_7","error_8","disconnect","error_9","reconnect","reset","error_10","transfer","portOrOps_1","portOrOps","register","value","operations","port","length","forEach","operation","index","offset","setUint32","length_2","error_11","transferBlock","countOrValues","dataSize","countOrValue","error_12","EventEmitter","PARTIAL_CHAR_TEST","DOUBLE_BYTE_REPLACE","TextDecoder","decode","input","numberArray","fromCodePoint","partialChar","match","replace","decoderReplacer","encoded","codePoint","codePointAt","leadingOnes","clz32","endPos","stringLen","decoder","DAPLink","serialPolling","serialListeners","on","event","EVENT_SERIAL_DATA","listenerCount","isBufferBinary","bufferString","i","charCode","charCodeAt","writeBuffer","buffer_1","pageSize_1","pageSize","end","min","page","emit","EVENT_PROGRESS","flash","source","isView","streamType","getSerialBaudrate","setSerialBaudrate","baudrate","serialWrite","arrayData","split","map","e","unshift","serialRead","serialData","dataLength","startSerialRead","serialDelay","autoConnect","connectedState","stopSerialRead","DEFAULT_AUTOINC_PAGESIZE","ADI","transportOrDap","proxy","waitDelay","fn_1","fn","timeout","running","concatTypedArray","arrays","_i","arrays_1","j","readDPCommand","writeDPCommand","selectedAddress","readAPCommand","address","writeAPCommand","cswValue","readMem8Command","writeMem8Command","readMem16Command","writeMem16Command","readMem32Command","writeMem32Command","transferSequence","merged","results","splice","push","mask","readDP","writeDP","readAP","writeAP","readMem8","writeMem8","readMem16","writeMem16","readMem32","writeMem32","readMem32Sequence","count","remainder","chunkSize","writeMem32Sequence","values","chunk","readBlock","nextPageOffset","writeBlock","readBytes","bytesToRead","endOffset","startOffset","writeBytes","bytesToWrite","CortexM","enableDebug","readCoreRegisterCommand","writeCoreRegisterCommand","getState","dhcsr","state","newDhcsr","isHalted","halt","wait","resume","readCoreRegister","readCoreRegisters","registers","registers_1","writeCoreRegister","execute","address_1","code_1","stackPointer_1","programCounter_1","code","stackPointer","programCounter","linkRegister","newCode","softReset","setTargetResetState","hardwareReset","exports","HID","device","os","reject","error","USB","interfaceClass","configuration","alwaysControlTransfer","bufferToDataView","bufferSourceToBuffer","bufferSource","Buffer","from","extendBuffer","setConfiguration","message","_b","interfaces","filter","iface","descriptor","bInterfaceClass","selectedInterface","find","endpoints","interfaceNumber","endpointIn","endpointOut","endpoints_1","endpoint","direction","claim","_e","exception","controlTransfer","LIBUSB_ENDPOINT_IN","extended","LIBUSB_ENDPOINT_OUT","WebUSB","selectConfiguration","alternates","claimInterface","transferIn","endpointNumber","controlTransferIn","requestType","recipient","transferOut","controlTransferOut"],"mappings":"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"}